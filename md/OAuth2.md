<!-- TOC -->

- [OAuth2.0](#oauth20)
  - [图解](#%E5%9B%BE%E8%A7%A3)

<!-- /TOC -->
# OAuth2.0

## 图解

1. **我们这里有一份用户的数据**

![图2](img/1.png)

2. **用户的数据我们保存在资源服务器 (Resource server) 里**

![图2](img/2.png)

3. **有个 第三方应用程序（Third-party application）想要请求资源服务器要用户数据**

![图3](img/3.png)

4. **为了让用户数据和第三方程序程序良好的交互，资源服务器准备了一个 API 接口**

![图4](img/4.png)

5. **第三方应用程序向资源服务器请求用户的数据**

![图5](img/5.png)

6. **资源服务器表示好的给你了**

![图6](img/6.png)

7. **但如果这个第三方应用程序是恶意的第三方呢？那么就会有以下的场景出现**

![图7](img/7.png)

8. **所以我们需要一个机制来保护 API 接口，不能随随便便毫无安全可言的把用户的数据送出去**

![图8](img/8.png)

9. **个最佳实践就事先在第三方程序里保存一个令牌 access_token**

![图9](img/9.png)

10. **第三方应用程序在向资源服务器请求用户数据的时候会出示这个 access_token**

![图10](img/10.png)

11. **然后资源服务器取出授权码并且验证是否有授权**
    ![图11](img/11.png)

12. **授权通过，资源服务器才会把用户数据传递给第三方应用程序**

![图12](img/12.png)

13. **但这种方案需要事先给第三方 access_token**

![图13](img/13.png)

14. **所以我们需要一个东西用来发行这个 access_token，这时候认证服务器 （Authorization server）登场了**

![图14](img/14.png)

15. **认证服务器负责生成并且发行 access_token 给第三方应用程序**

![图15](img/15.png)

16. **接下来我们看一下目前的登场的人物有**


    -   第三方应用程序
    -   资源服务器
    -   认证服务器
    -   access_token
    -   用户数据

> 资源服务器和认证服务器有时候是同一台服务器

![图16](img/16.png)

17. **接下来我们来走一下流程 认证服务器生成 access_token**

![图17](img/17.png)

18. **认证服务器发行 access_token 授权给第三方应用程序**

![图18](img/18.png)

19. **第三方应用程序拿着 access_token 去找资源服务器要用户数据**

![图19](img/19.png)

20. **资源服务器取出来 access_token 并验证**

![图20](img/20.png)

21. **验证通过 用户数据送出**
    ![图21](img/21.png)

22. **问题点来了**
    > 到上面为止有个很大的问题就是，认证服务器生成 access_token 竟然没人管！那岂不是随便发行了，这不行，于是我们的用户 （Resource Owner：资源所有者）出现了！

![图22](img/22.png)

23. **解决**

>认证服务器在发行 access_token 之前要先通过用户的同意

24. **第三方应用程序向认证服务器要 access_token**

![图23](img/23.png)

25. **认证服务器生成之前先问问用户能不能授权啊**

![图24](img/24.png)

26. **用户说好的可以给**

![图25](img/25.png)

27. **认证服务器生成 access_token 并且发行给第三方应用程序**

![图26](img/26.png)   

28. **oAuth2.0**

> 第三方应有程序和这个认证服务器之间围绕着 access_token 进行请求和响应的等等就是 oAuth2.0

![图27](img/27.png)


