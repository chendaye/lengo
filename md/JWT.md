# JWT

## TOKEN

> token 是一串字符串，通常因为作为鉴权凭据，最常用的使用场景是 API 鉴权。

### API 鉴权

#### cookie + session

> 和平常 web 登陆一样的鉴权方式，很常见，不再赘述。

#### HTTP Basic

> 将账号和密码拼接然后 base64 编码加到 header 头中。很显然，因为账号和密码几乎是『明文』传输的，而且每次请求都传，安全性可想而知。

#### HTTP Digest

> 将账号和密码加上其他一些信息拼接然后取摘要加到 header 头中。这个安全性比上面要好一点，因为如果是取摘要的话，即使信息段被截取，也无法轻易破解出来（当然也是有破解的可能）。
> 不过其实最大的问题还是：每次请求都要对账号、密码取一次摘要，也就是说每次请求都要有账号和密码，也就是说账号和密码要么缓存一下，要么就每次请求要去用户输一次密码，这样显然不合适。同样，上面的 Basic 也存在这样的问题

#### Token

> token 通过一次登录验证，得到一个鉴权字符串，然后以后带着这个鉴权字符串进行后续操作，这样就可以解决每次请求都要带账号密码的问题，而且也不需要反复使用账号和密码。

### Token 的优势

#### CSRF 攻击

> 这个原理不多做介绍，构成这个攻击的原因，就在于 Cookie + Session 的鉴权方式中，鉴权数据（cookie 中的 session_id）是由浏览器自动携带发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。而 token 是通过客户端本身逻辑作为动态参数加到请求中的，token 也不会轻易泄露出去，因此 token 在 CSRF 防御方面存在天然优势。

#### 适合移动应用

> 移动端上不支持 cookie，而 token 只要客户端能够进行存储就能够使用，因此 token 在移动端上也具有优势。

### Token 的种类

-   一般来说 token 主要三种：

    -   自定义的 token：开发者根据业务逻辑自定义的 token
    -   JWT：JSON Web Token，定义在 RFC 7519 中的一种 token 规范
    -   Oauth2.0：定义在 RFC 6750 中的一种授权规范，但这其实并不是一种 token，只是其中也有用到 token

## JWT 的组成和优势

> JWT 全称 JSON Web Tokens ，是一种规范化的 token。可以理解为对 token 这一技术提出一套规范，是在 RFC 7519 中提出的。

### 组成

> 一个 JWT token 是一个字符串，它由三部分组成，头部、载荷与签名，中间用 . 分隔，例如：xxxxx.yyyyy.zzzzz

#### 头部（header）

> 头部通常由两部分组成：令牌的类型（即 JWT）和正在使用的签名算法（如 HMAC SHA256 或 RSA.）

```js
{
  "alg": "HS256",
  "typ": "JWT"
}
```

#### 载荷（Payload）

> 载荷中放置了 token 的一些基本信息，以帮助接受它的服务器来理解这个 token。同时还可以包含一些自定义的信息，用户信息交换

-   载荷的属性也分三类
    -   预定义（Registered）
    -   公有（public）
    -   私有（private）

```js
{
  "sub": "1",
  "iss": "http://localhost:8000/auth/login",
  "iat": 1451888119,
  "exp": 1454516119,
  "nbf": 1451888119,
  "jti": "37c107e4609ddbcc9c096ea5ee76c667",
  "aud": "dev"
}
```

> 这里面的前 7 个字段都是由官方所定义的，也就是预定义（Registered claims）的，并不都是必需的

-   iss (issuer)：签发人
-   sub (subject)：主题
-   aud (audience)：受众
-   exp (expiration time)：过期时间
-   nbf (Not Before)：生效时间，在此之前是无效的
-   iat (Issued At)：签发时间
-   jti (JWT ID)：编号

##### 公有的载荷

> 在使用 JWT 时可以额外定义的载荷。为了避免冲突，应该使用 IANA JSON Web Token Registry 中定义好的，或者给额外载荷加上类似命名空间的唯一标识。

##### 私有载荷

> 在信息交互的双方之间约定好的，既不是预定义载荷也不是公有载荷的一类载荷。这一类载荷可能会发生冲突，所以应该谨慎使用。
> 将上面的 json 进行 Base64Url 编码得到载荷，，即 yyyyy

> 关于载荷的理解：

这里三种载荷的定义应该明确的一点是 —— 对于后两种载荷，它并非定义了载荷的种类，然后让你去选用哪种载荷，而是对你可能会定义出来的载荷做一个分类。

比如你定义了一个 admin 载荷，这个载荷按其分类应该是私有载荷，可能会和其他人定义的发生冲突。但如果你加了一个前缀（命名空间），如 namespace-admin，那么这应该就算一个公有载荷了。（但其实标准并没有定义怎么去声明命名空间，所以严格来说，还是可能会冲突）

但是在现实中，团队都是约定好的了要使用的载荷，这样的话，好像根本不存在冲突的可能。那为什么文档要这么定义呢？我的理解是，RFC 是提出一种技术规范，出发点是一套通用的规范，考虑的范围是所有开发者，而不仅仅局限于一个开发者团队。就像用 token 做认证已经是很常见的技术了，但是 JWT 的提出就相当于提出了一套较为通用的技术规范。既然是为了通用，那么考虑在大环境下的冲突可能性也是必须的。

#### 签名（Signature）

> 签名时需要用到前面编码过的两个字符串，如果以 HMACSHA256 加密，就如下

```js
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret);
```

> 加密后再进行 base64url 编码最后得到的字符串就是 token 的第三部分 zzzzz。
>
> > 组合便可以得到 token：xxxxx.yyyyy.zzzzz。
> >
> > > 签名的作用：保证 JWT 没有被篡改过，原理如下：

>>>>HMAC 算法是不可逆算法，类似 MD5 和 hash ，但多一个密钥，密钥（即上面的 secret）由服务端持有，客户端把 token 发给服务端后，服务端可以把其中的头部和载荷再加上事先共享的 secret 再进行一次 HMAC 加密，得到的结果和 token 的第三段进行对比，如果一样则表明数据没有被篡改。
Hash-based Message Authentication Code


#### 使用

* JWT 的使用有两种方式：
    * 加到 url 中：?token=你的token
    * 加到 header 中，建议用这种，因为在 https 情况下更安全：Authorization:Bearer 你的token
  
* JWT 在客户端的存储有三种方式
  * LocalStorage
  * SessionStorage
  * Cookie [不能设置 HTTPonly]

>但是最推荐的还是第三种，因为第一二种存在跨域读取限制，而 Cookie 使用不同的跨域策略
